# 简洁模式拖拽落位偏差修复（2026-02-09）

## 问题现象
手动排序时，拖拽过程动画与占位正常，但松手后便笺偶发落到非预期位置（常见于快速拖动后立即松手）。

## 根因
拖拽收尾流程在 `pointerup` 阶段直接 finalize，没有使用“松手瞬间的指针位置”再计算一次目标索引。
这会导致最终持久化位置沿用上一次 `pointermove` 的计算结果，出现 1 项左右的偏差。

## 修复方案
1. 抽取统一函数 `applyDropTargetByPointer(pointerY)`，负责按当前指针坐标计算并应用目标索引。
2. `pointermove` 继续调用该函数实时更新预览顺序。
3. 在 `pointerup` / 窗口级 `pointerup` 收尾时，先用当前 `clientY` 调用该函数，再执行 `finalizeVerticalDrag()`。

## 影响文件
- `src/lib/panel/use-drag-reorder.js`

## 验证建议
- 在简洁模式 + 手动排序下，快速跨多条拖拽并立刻松手，确认最终落位与松手位置一致。
- 在列表顶部/底部触发自动滚动后松手，确认落位稳定。

## 二次修正（索引计算策略）
上一次修复后仍存在“空位正确但落位错误”的情况，根因是目标位计算时仍把被拖拽项自身参与了命中计算。

本次改为两段式算法：
1. 在 DOM 命中计算里排除 `.drag-placeholder`（即被拖拽项）；
2. 先从当前列表移除被拖项，再按插入位（insertion index）插回。

这样目标位与用户看到的空位一一对应，不再依赖 `insertionIndex > currentIndex` 的补偿分支。
