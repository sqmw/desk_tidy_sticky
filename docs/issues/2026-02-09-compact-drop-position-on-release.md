# 简洁模式拖拽落位偏差修复（2026-02-09）

## 问题现象
手动排序时，拖拽过程动画与占位正常，但松手后便笺偶发落到非预期位置（常见于快速拖动后立即松手）。

## 根因
拖拽收尾流程在 `pointerup` 阶段直接 finalize，没有使用“松手瞬间的指针位置”再计算一次目标索引。
这会导致最终持久化位置沿用上一次 `pointermove` 的计算结果，出现 1 项左右的偏差。

## 修复方案
1. 抽取统一函数 `applyDropTargetByPointer(pointerY)`，负责按当前指针坐标计算并应用目标索引。
2. `pointermove` 继续调用该函数实时更新预览顺序。
3. 在 `pointerup` / 窗口级 `pointerup` 收尾时，先用当前 `clientY` 调用该函数，再执行 `finalizeVerticalDrag()`。

## 影响文件
- `src/lib/panel/use-drag-reorder.js`

## 验证建议
- 在简洁模式 + 手动排序下，快速跨多条拖拽并立刻松手，确认最终落位与松手位置一致。
- 在列表顶部/底部触发自动滚动后松手，确认落位稳定。

## 二次修正（索引计算策略）
上一次修复后仍存在“空位正确但落位错误”的情况，根因是目标位计算时仍把被拖拽项自身参与了命中计算。

本次改为两段式算法：
1. 在 DOM 命中计算里排除 `.drag-placeholder`（即被拖拽项）；
2. 先从当前列表移除被拖项，再按插入位（insertion index）插回。

这样目标位与用户看到的空位一一对应，不再依赖 `insertionIndex > currentIndex` 的补偿分支。

## 三次修正（松手不再二次重算）
后续仍有复现：拖拽过程中的空位显示正确，但松手后会偏移到邻近位置。

### 根因
`pointerup` 阶段再次按当前指针坐标重算目标插入位，可能与“最后一帧预览状态”不一致（尤其快速拖动时），导致最终持久化结果覆盖了用户最后看到的空位。

### 修复
1. 拖动过程中（`pointermove`）继续实时计算并更新预览顺序；
2. 松手阶段（组件内 `onVerticalDragEnd` 与窗口级 `pointerup`）不再重算落点；
3. `finalizeVerticalDrag` 直接采用当前 `dragPreviewNotes` 作为最终顺序提交。

### 结果
最终落位与松手前用户看到的空位保持一致，避免“视觉正确但落位错位”的体验问题。

## 四次修正（首条便笺拖拽异常）
仍有用户反馈：第一个便笺相关拖拽异常（拖走第一条或拖到第一条位置都不稳定）。

### 根因
- 同组拖拽命中逻辑依赖 `data-note-id`，但列表项未挂该属性，导致首条及边界位置命中不稳定。

### 修复
1. 列表项补充 `data-note-id`，拖拽命中改为“DOM 实际行 ↔ noteId ↔ 当前预览列表索引”映射；
2. 保持“钉住在上”的产品语义：
   - 后端排序继续在 custom/newest/oldest 下都先按 `isPinned` 分组；
   - 前端仅允许同 pin 分组内拖拽重排；
3. 松手阶段仍不做二次重算，直接以最后预览顺序落库。

### 结果
- 第一条相关拖拽（拖走第一条 / 拖到第一条）命中稳定；
- 预览空位、松手落点、持久化顺序一致；
- “钉住在上”的语义不被破坏。
